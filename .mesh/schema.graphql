schema {
  query: Query
  mutation: Mutation
}

directive @oneOf on INPUT_OBJECT | FIELD_DEFINITION

type Query {
  buyer(shipmentId: String!): User!
  delay(country: String!, extendedDateFormat: Boolean, id: String!, timeZone: String!): Delay!
  destination(id: String!): Destination!
  getReturnShipments(id: String!): [ReturnShipment]
  getShipmentId(input: SearchByValue!): [ShipmentId]
  inbound(id: String!): Inbound!
  inboundInventories(id: String!): InboundInventories!
  inboundInventoriesPaging(id: String!, limit: Int!, offset: Int!): InboundInventoriesResult!
  inboundPenalties(id: String!, limit: Int!, offset: Int!): InboundPenalties!
  incidences(shipment: ID!): [Incidence]
  inventory(id: String!): InventoryItem!
  inventoryAddresses(id: String!): [InventoryAddress]!
  inventoryInbounds(inventoryId: String!, limit: Int!, offset: Int!, sellerId: String!, status: String): InventoryInbounds!
  inventoryMovements(inventoryId: String!, limit: Int!, offset: Int!, processName: String): InventoryMovementsResult!
  inventoryMovementsAll(id: String!): [InventoryMovement]!
  inventoryRecommendationsItem(inventoryID: String!): InventoryRecommendationsItem
  item(id: String!): Item!
  itemHistory(from: String!, id: String!, limit: Int!, offset: Int!, to: String!): History!
  itemHistoryV2(from: String!, id: String!, limit: Int!, offset: Int!, to: String!): HistoryItem!
  logisticCenter(logisticCenterId: String!): LogisticCenter
  meLogistic(sellerID: String!): MELogistic
  orderHistory(from: String!, id: String!, limit: Int!, offset: Int!, to: String!): History!
  orderHistoryV2(from: String!, id: String!, limit: Int!, offset: Int!, to: String!): HistoryOrder!
  orders(orders: OrderIDS!): [Order]
  paymentDetail(order: String!): PaymentDetail
  payments(input: PaymentsInput!): [Payment]
  searchUser(input: SearchByValue!): String!
  seller(id: String!): Seller
  sellerInbounds(id: String!, limit: Int!, offset: Int!): SellerInbounds!
  sellerInventories(id: String!, limit: Int!, offset: Int!): SellerInventories!
  sellerPenalties(id: String!, limit: Int!, offset: Int!): InboundPenalties!
  sellerPricingWarehousings(fromDate: String!, id: String!, toDate: String!): SellerPricingWarehousings!
  sellerProperties(userId: String!): SellerProperties!
  sellerWithdrawals(id: String!, limit: Int!, offset: Int!): SellerWithdrawals!
  shipment(id: String!): Shipment!
  shipmentStatusHistory(id: String!): ShipmentStatusHistory!
  step(id: String!): Step!
  timeline(shipmentId: String!): TimeLine!
  tmsInfo(shipmentId: String!): TmsInfo!
  tracking(id: String!): Tracking!
  user(id: String!): User!
  withdrawal(id: String!): Withdrawal!
  getWithdrawalsRequest(id: BigInt!): WithdrawalRequest
  searchWithdrawalRequests(id: [BigInt], seller_id: [BigInt], status: [String], site_id: [String], type: [String], version: [String], inventory_id: [String], appointment_date: [String], title: [String], query: String, shipment_type: [String], default_warehouse_id: [String], appointment_date_from: String, appointment_date_to: String, sort_by: String, offset: Int, limit: Int = 50): SearchResultsWithdrawalRequest
  getWithdrawalsRequestLocations(id: BigInt!): String
  getWithdrawalsRequestHistory(id: BigInt!): [StatusHistoryWithdrawalsRequestStatus]
  getWithdrawal(id: BigInt!): Withdrawal
  searchWithdrawals(id: [BigInt], withdrawal_request_id: [BigInt], code: [String], seller_id: [BigInt], status: [String], warehouse_id: [String], site_id: [String], inventory_id: [String], appointment_date: [String], appointment_date_from: String, appointment_date_to: String, shipment_type: [String], query: String, sort_by: String, offset: Int, limit: Int = 50): SearchResultsWithdrawal
  getWithdrawalReadyToDispatchInfo(code: String!): DispatchInfo
  getWithdrawalsContainer(id: String!): WithdrawalContainer
  searchWithdrawalContainers(id: [String], withdrawal_id: [BigInt], parcel_id: [String], status: [String], inventory_id: [String], storage_address: [String], site_id: [String], warehouse_id: [String], shipment_type: [String], tracking_id: [String], shipment_order_id: [String], sort_by: String, offset: Int, limit: Int = 50): SearchResultsWithdrawalContainer
  getWithdrawalsContainerTrackingInfo(id: String!): WithdrawalContainerTrackingInfo
  getDocuments(id: String!): ContainerDocuments
  "Ping endpoint, used to know if the app is up."
  ping_ping_get: JSON
  "List"
  list_teams_get(username: String, match: String, orderTeam: TeamOrderEnum, limit: Int): [list_teams_get_response]
  "Get By Team Code"
  get_by_team_code_teams__team_code__get(team_code: String!): get_by_team_code_teams__team_code__get_response
  "Get Teams By Username"
  get_teams_by_username_teams_user__username__get(username: String!): [get_teams_by_username_teams_user__username__get_response]
  "Get Team Collaborators"
  get_team_collaborators_teams__team_code__collaborators_get(team_code: String!): get_team_collaborators_teams__team_code__collaborators_get_response
  "Get Applications By Team Code"
  get_applications_by_team_code_teams__team_code__applications_get(team_code: String!): [get_applications_by_team_code_teams__team_code__applications_get_response]
  "List"
  list_role_get: [RoleResponse]
}

type Mutation {
  activateCBTAccount(userId: String!): Boolean!
  activateDO(carrierActivation: String!, userId: String!): Boolean!
  activateFulfillment(userId: String!, warehouseId: String): Boolean!
  activateFulfillmentMLB(input: FulfillmentMLB!): Boolean!
  activateXD(input: CrossDocking!): Boolean!
  activateXDDO(placeId: String!, userId: String!, warehouseId: String!): Boolean!
  addMode(option: String!, shippingMode: String!, userId: String!): Boolean!
  addOptionalMode(shippingMode: String!, userId: String!): Boolean!
  changeAxado(token: String!, userId: String!): Boolean!
  changeCBTCarrier(carrier: String!, countryId: String!, siteId: String!, userId: String!): Boolean!
  changeCBTStatus(input: ChangeCBTStatusInput!): Boolean!
  changeHandlingTime(handlingTime: Int!, logisticType: String!, userId: String!): Boolean!
  changeMode(option: String!, shippingMode: String!, userId: String!): Boolean!
  changeStatus(input: ChangeStatusInput!): Boolean!
  changeTrackingNumber(input: ChangeTrackingNumberInput!): Boolean!
  deactivateFulfillment(userId: String!): Boolean!
  deactivateSelfService(userId: String!): Boolean!
  deleteOptionalMode(shippingMode: String!, userId: String!): Boolean!
  editDO(carrierActivation: String!, userId: String!): Boolean!
  editFBMPickUp(userId: String!): Boolean!
  editFragile(fragile: Boolean!, userId: String!): Boolean!
  editFulfillment(userId: String!, warehouseId: String): Boolean!
  editXD(input: CrossDocking!): Boolean!
  editXDDO(placeId: String!, userId: String!, warehouseId: String!): Boolean!
  fraudProcess(input: FraudProcessInput!): Boolean!
  getModeActions(sellerId: String!): [ModeActions!]
  mandatoryME(comment: String!, status: Boolean!, userId: String!): Boolean!
  printLabel(input: PrintLabelInput!): printLabelOutput!
  regenerateLabel(input: RegenerateLabelInput!): Boolean!
  removeFlammableTag(id: String!): Boolean!
  reputationTag(input: ReputationTagInput!): Boolean!
  resetHandlingTime(logisticType: String!, userId: String!): Boolean!
  deleteWithdrawalRequestProjection(id: BigInt!): String
  deleteWithdrawalProjection(id: BigInt!): String
  processWithdrawalRequestEventMessage(input: BigQueueMessage_Input): String
  processWithdrawalEventMessage(input: BigQueueMessage_Input): String
  processWithdrawalEventMessage_1(input: BigQueueMessage_Input): String
  deleteWithdrawalContainerProjection(id: String!): String
  "Create"
  create_teams_post(x_tiger_token: String, input: TeamRequest_Input): create_teams_post_response
  "Update"
  update_teams__team_code__put(x_tiger_token: String, team_code: String!, input: TeamUpdateRequest_Input): update_teams__team_code__put_response
  "Delete"
  delete_teams__team_code__delete(x_tiger_token: String, team_code: String!): delete_teams__team_code__delete_response
  "Refresh"
  refresh_teams__team_code__refresh_post(team_code: String!): refresh_teams__team_code__refresh_post_response
  "Exit Collaborator"
  exit_collaborator_teams_exit_collaborator_post(input: SquidExitCollaboratorMessage_Input): exit_collaborator_teams_exit_collaborator_post_response
  "Create"
  create_role_post(input: RoleRequest_Input): create_role_post_response
  "Sync"
  sync_temporary_role_sync_post: JSON
}

type Action {
  body: [String!]
  disabled: Boolean!
  label: String!
  method: String!
  name: String!
  params: [String!]
  reason: String!
}

type Address {
  address: String!
  types: [String!]!
  id: BigInt
}

type Attribute {
  id: String!
  name: String!
  source: String!
  valueId: String!
  valueName: String!
}

type AvailableFilters {
  id: String!
  name: String!
  values: [FilterValue]
}

type Buyer {
  address_line: String!
  doc_type: String!
  email: String!
  full_name: String!
  id: String!
  identification: Identification!
  nickname: String!
  phone: String!
  scoring: String!
}

type Capacities {
  availables: [Int!]
  currentCount: Int!
  selected: Int!
}

type CarrierLabeling {
  ID: Int!
  Name: String!
}

type CaseDataInp {
  associatedPublicationId: [String]
  identificationCounter: Int
  physicalProductGtin: String
  productExpirationDates: [String]
  tags: [TagCaseInp]
}

input ChangeCBTStatusInput {
  id: String!
  shippingStatusNew: String!
  shippingSubStatusNew: String!
}

input ChangeStatusInput {
  id: String!
  minimumChangeDate: String!
  shippingStatusNew: String!
  shippingSubStatusNew: String!
}

input ChangeTrackingNumberInput {
  id: String!
  trackingNumber: String!
  trackingNumberNew: String!
}

type Checkpoint {
  checkpointDate: String!
  dateCreated: String!
  shipmentStatus: String!
  shipmentSubstatus: String!
}

type Claim {
  detail: SummaryClaims
  mediation: [MediationMessage]
}

type ComparisonChanges {
  modifiedField: String!
  newValue: String!
  oldValue: String!
}

type Comparisons {
  changeDate: String!
  comparisonChanges: [ComparisonChanges]
  snapshot: String!
}

type CostComponents {
  freeListingAdditionalAmount: Float!
  freeShippingAmount: Float!
  gapDiscount: Float!
  insurance: Float!
  loyalCartDiscount: Float!
  loyalDiscount: Float!
  mandatoryFsDiscount: Float!
  meliGmvDiscount: Float!
  meliRatioAdjustiment: Float!
  normalDiscount: Float!
  roundingDifference: Float!
  routeDiscount: Float!
  ruleCost: Float!
  sellerGmvAggregatedDiscount: Float!
  sellerMarketplaceFee: Float!
  sellerShippingFee: Float!
  specialDiscount: Float!
}

input CrossDocking {
  aditionalInfo: String!
  city: String!
  dailyDetailedSchedule: [DailyDetailedItemDTO]
  milkRunConfigType: String!
  neighborhood: String!
  placeID: String!
  route: String!
  sellerID: String!
  sellerName: String!
  siteID: String!
  state: String!
  stop: String!
  streetName: String!
  streetNumber: String!
  userID: String!
  warehouseID: String!
  zipCode: String!
}

type Crossdocking {
  logisticInfo: LogisticInfo
  milkrunHistory(date: String!): [MilkrunHistory]
  sellerID: String!
}

type CrossdockingDropOff {
  logisticInfo: LogisticInfo
  sellerID: String!
}

type Currency {
  decimal_places: Int!
  description: String!
  id: String!
  symbol: String!
}

type Cutoffs {
  availables: [ValueUnit!]
  selected: ValueUnit
}

input DailyDetailedItemDTO {
  carrierID: String!
  carrierName: String!
  day: Int!
  endTime: String!
  id: String!
  logisticCenter: String!
  startTime: String!
}

type DataDisposalInventory {
  closeDisposalDate: String
  disposalQuantity: String
}

type Delay {
  extendedDateExtended: dateTm!
  extendedDateFinal: dateTm!
  extendedDateLimit: dateTm!
  extendedDateLimitReceiver: dateTm!
  promiseLimit: PromiseLimit
  returnTime: String!
}

type DeliveryPromise {
  dateCreated: String!
  from: String!
  reason: String!
  rescheduled: Boolean!
  stage: String!
  to: String!
  type: String!
}

type Destination {
  id: String!
  receiverId: String!
  receiverName: String!
  receiverPhone: String!
  returnAddress: String!
  shippingAddress: String!
  type: String!
}

type DetailInp {
  addressId: String
  quantity: Int
}

type Dimension {
  height: String!
  length: String!
  weight: String!
  width: String!
  value: Float
  measure_unit: query_getWithdrawalsContainer_dimensions_length_measure_unit
}

type Dimensions {
  cubicWeight: String!
  dimensions: Dimension!
  source: Source!
  length: Dimension
  width: Dimension
  weight: Dimension
  height: Dimension
}

type Discount {
  promotedAmount: Float!
  rate: Float!
  type: String!
}

type DropOff {
  logisticInfo: LogisticInfo
  sellerID: String!
}

type EventInp {
  createdAt: String
  description: String
  id: ID!
  identifiedProductID: String
  newStatus: String
  subMotives: [SubMotiveInp]
}

type FbmCharge {
  action: String!
  amount: String!
  amountPerUnit: String!
  currencyId: String!
  details: FbmChargeDetail!
  ean: String!
  id: ID!
  inventoryId: String!
  inventoryType: String!
  itemId: String!
  itemName: String!
  newsDate: String!
  referenceId: String
  sellerId: String!
  siteId: String!
  sku: String!
  type: String!
  variation: String!
}

type FbmChargeDetail {
  amountPerVolumeUnit: String
  inboundId: String
  penaltyType: String
  quantity: Int
  shipmentType: String
  volume: String
  volumeType: String
  volumeUnit: String
  withdrawalId: String
}

type FilterValue {
  id: String!
  name: String!
  results: Int!
}

type Flex {
  logisticInfo: LogisticInfo
  selfServiceConfiguration: SelfServiceConfiguration
  userId: String!
}

type FlexAllowed {
  activationDate: String!
  allowed: Boolean
  causes: [String!]
}

input FraudProcessInput {
  id: String!
  shippingStatusNew: String!
  shippingSubStatusNew: String!
}

type FromTo {
  from: String!
  isBold: Boolean!
  isGrey: Boolean!
  to: String!
  unit: String!
}

type Fulfillment {
  logisticInfo: LogisticInfo
  sellerID: String!
}

input FulfillmentMLB {
  isFillial: Boolean!
  sellerBilling: SellerBilling!
  subsidiary: UserSubsidiary!
  userId: String!
  warehouseId: String!
}

type FulfillmentRestriction {
  dimensionsOrigin: String!
  restricted: Boolean!
  restrictionCause: String!
}

type GenericNameValue {
  name: String!
  value: String!
  verified: Boolean!
}

type Geometry {
  coordinates: [[[Float!]]]
  type: String!
}

type HandlingTime {
  unit: String!
  value: String!
}

type HandlingTimePredictions {
  day: Int!
  hour: Int!
  value: Int!
}

type Header {
  buyer: Buyer!
  cart: Boolean!
  id: String!
  logistic_title: String!
  marketplace: String!
  search_type: String!
}

type History {
  comparisons: [Comparisons!]
  paging: Paging!
}

type HistoryItem {
  historyItem: [itemHistory]
  paging: Paging
}

type HistoryOrder {
  historyOrder: [orderHistory]
  paging: Paging
}

type IdName {
  id: String!
  name: String!
}

type Identification {
  number: String!
  type: String!
}

type Inbound {
  appointmentDate: String!
  appointmentTimeSlot: String!
  confirmationDate: String
  dateCreated: String!
  declaredPackages: String!
  declaredUnits: String!
  fbppTicketsAlfred: [String!]
  id: ID!
  inboundCharges: [FbmCharge]
  inboundMilkRunsPlannig: InboundMilkRunPlannig
  inboundPenalties: [InboundPenalty]
  inboundPlanId: Int
  inventories: [InboundInventory]
  inventoryProblems: [InventoryProblem]
  receivedPackages: String!
  receivedUnits: String!
  receptionDate: String!
  sellerId: ID!
  shipmentType: String!
  siteId: String!
  status: String!
  type: String
  warehouseId: String!
}

type InboundInventories {
  hasQuantityDifferences: Boolean!
  inventories: [InboundInventory!]
}

type InboundInventoriesResult {
  paging: Paging!
  results: InboundInventories
}

type InboundInventory {
  declaredUnits: String!
  dimensions: Dimension
  id: ID!
  inboundId: String!
  insuranceCost: String!
  inventoryProblem: InventoryProblem
  inventoryProblemINP: [InventoryProblemINP]
  itemId: String!
  receivedUnits: String!
  siteId: String!
  title: String!
  warehouseInbound: String!
}

type InboundMilkRunPlannig {
  customerId: Int
  inboundMilkRunsRunning: [InboundMilkRunRunning]
  milkRunDays: [MilkRunDay]
  siteId: String
}

type InboundMilkRunRunning {
  carrier: MilkRunGenericEntity
  collectedPackage: Int
  deliveredNoteId: String
  documentId: String
  driver: MilkRunDriver
  estimatedPackage: Int
  facilityId: String
  finishMilkRunTime: String
  incidentType: MilkRunIncidentType
  logisticType: String
  milkRunStatus: String
  milkRunTime: String
  orderId: String
  outOfRange: Boolean
  outOfRangeDistance: String
  outOfRangeGeolocationType: String
  routeDate: String
  routeId: String
  routeName: String
  seller: MilkRunSellerEntity
  site: String
  startMilkRunTime: String
  topSeller: Boolean
  vehicle: MilkRunVehicle
}

type InboundPenalties {
  availableFilters: [AvailableFilters]
  filters: Map
  paging: Paging!
  results: [InboundPenalty]
}

type InboundPenalty {
  bonificationType: String
  bookingId: String!
  bookingSource: String
  category: String
  chargeStatus: String
  chargesInboudPenalty: [FbmCharge]
  concept: String
  currency: String
  dateCreated: String
  dateUpdated: String
  detail: InboundPenaltyDetail!
  eventDate: String
  id: ID!
  inboundId: String!
  sellerId: String!
  shipmentType: String
  sourceId: String
  status: String
  totalAmountToPay: String
  totalBonificationAmount: String
  totalChargeAmount: String
  warehouseId: String!
}

type InboundPenaltyDetail {
  appointmentArrivalDate: String!
  appointmentCancellationDate: String
  appointmentCancellationLimitDate: String
  appointmentDate: String!
  dateCreated: String!
  dateUpdated: String!
  id: ID!
  penaltyUnits: String!
  toleranceDifference: String
  totalUnitsDeclared: String
  totalUnitsReceived: String
}

type Incidence {
  category: String!
  category_description: String!
}

type IncidentsInp {
  id: ID!
  pictures: [String]
  quantity: Int
  source: String
  sourceId: String
}

type InventoryAddress {
  addressId: ID!
  availableQuantity: Int!
  reservedQuantity: Int!
  sellerProductId: String!
  totalQuantity: Int!
  warehouseId: String!
}

type InventoryDimensions {
  height: InventoryDimensionsUnit
  length: InventoryDimensionsUnit
  weight: InventoryDimensionsUnit
  width: InventoryDimensionsUnit
}

type InventoryDimensionsUnit {
  measureUnit: String
  value: String
}

type InventoryFeeDetail {
  date: String
  stockDetails: [StockFeeDetail]
  totalFeeAmount: String
  totalQuantity: String
}

type InventoryInbounds {
  availableFilters: [AvailableFilters]
  paging: Paging!
  results: [Inbound]
}

type InventoryItem {
  dataDisposalInventory: DataDisposalInventory
  dimensions: InventoryDimensions
  fbppTicketsAlfred: [String!]
  fulfillmentActive: Boolean!
  identifiers: [GenericNameValue]
  insuranceCost: String!
  inventoryId: ID!
  itemId: String!
  itemIsConsistent: Boolean!
  sellerId: String!
  siteId: String!
  stockDetailWithLocation: StockDetailWithLocation
  title: String!
  variationId: String!
}

type InventoryMovement {
  clientId: String
  dateCreated: String!
  externalReferences: Map
  fiscalCoverage: String
  id: ID!
  itemId: String!
  locationId: String!
  movements: [Int]
  processName: String!
  quantity: String!
  reservations: [Int]
  sellerProductId: String!
  transactionId: String
  userId: String!
  userName: String!
}

type InventoryMovementsResult {
  availableFilters: [AvailableFilters]
  filters: Map
  paging: Paging!
  results: [InventoryMovement]
}

type InventoryProblem {
  category: String!
  inventoryId: String!
  message: String!
  pictures: [String]
  subCategory: String!
}

type InventoryProblemINP {
  caseData: CaseDataInp
  category: String
  createdAt: String
  description: String
  details: [DetailInp]
  events: [EventInp]
  id: ID!
  identification: String
  incidents: [IncidentsInp]
  quantity: Int
  sellerProductId: String
  status: String
  subCategory: String
  updatedAt: String
  warehouseId: String
}

type InventoryQuantityItem {
  arrivalStock: String
  availableStock: String
  delta: String
  hasForecast: Boolean
  itemID: String
  limits: [LimitsQuantityItem]
  stockSurplus: String
  variationID: String
}

type InventoryRecommendationsItem {
  inventoryQuantityRecommendations: InventoryQuantityItem
  inventoryRecommendationsDetail: InventoryQuantityItem
}

type InventoryWarehosingCharge {
  currencyID: String
  details: [InventoryFeeDetail]
  inventoryID: String
  inventoryInfo: InventoryItem
  sellerID: String
  size: String
  totalFeeAmount: String
}

type Item {
  actions: [Action]
  dimensions: Dimensions
  fulfillmentRestriction: FulfillmentRestriction
  inventories: [String!]
  itemDetail: ItemDetail!
  seller: User
  shippingPreferences: ShippingPreferences
}

type ItemAttribute {
  id: String
  name: String
  source: Int
  valueId: String
  valueName: String
}

type ItemDetail {
  catalogId: String!
  categoryId: String!
  condition: String!
  digital: Boolean!
  dimensionsExceeded: Boolean!
  flammable: Boolean!
  flex: Boolean!
  freeShipping: Boolean
  id: String!
  inventoryId: String
  lostMe2ByDimensions: Boolean!
  permalink: String!
  price: String!
  saleTerms: [SaleTerms!]
  shipping: Shipping
  status: String!
  thumbnail: String!
  title: String!
  variations: [ItemVariations]
}

type ItemDetailHistory {
  CategoryId: String
  Condition: String
  Id: String
  Title: String
  VariationId: Int
  Warranty: String
}

type ItemPicture {
  secureUrl: String
  url: String
}

type ItemSTValueStruct {
  number: String!
  unit: String!
}

type ItemSaleTerms {
  id: String
  valueStruct: ItemSTValueStruct
}

type ItemShipping {
  dimensions: String
  freeMethod: String
  freeShipping: Boolean
  localPickup: Boolean
  logisticType: String
  mode: String
  storePickUp: Boolean
  tags: [String]
}

type ItemVariation {
  attributeCombinations: [ItemAttribute]
  attributes: [ItemAttribute]
  availableQuantity: Int
  catalogProductId: String
  id: Int
  inventoryId: String
  price: Float
  soldQuantity: Int
}

type ItemVariations {
  id: String
  inventoryId: String
}

type Labeling {
  AddressLine: String!
  Carrier: CarrierLabeling!
  GenerateDate: String!
  LastPrintUser: String!
  PrintDate: String!
  Reason: String!
  Route: String!
  UserID: String!
  WorkstationID: Int!
}

type Lead {
  deliveryRange: FromTo
  estimatedDeliveryTime: FromTo!
  handlingDelay: Boolean!
  handlingTime: HandlingTime!
  limitHandlingTime: String!
  manufacturingTime: String!
  originalPromiseDeliveryTime: FromTo!
  promiseDeliveryTime: FromTo!
  recalculatedPromises: [DeliveryPromise]
  returnTime: ReturnTime
  shippingDelay: Boolean!
}

type LimitsQuantityItem {
  id: String
  value: String
}

type LocationDetail {
  fiscalCoverage: Map
  inLocation: Map
  inLocationProcessing: Map
  inTransfer: Map
  locationId: String
  locationType: String
  saleable: Int
  total: Int
}

type Logistic {
  mode: String!
  types: [String!]
}

type LogisticCenter {
  address: LogisticCenterAddress
  dateCreated: String!
  id: String!
  logisticCategories: [String]
  logisticProvider: String!
  name: String!
  shortName: String!
  siteId: String!
  status: String!
  type: String!
}

type LogisticCenterAddress {
  addressLine: String!
  agency: String
  city: IdName
  comment: String!
  country: IdName
  geolocationType: String!
  id: String
  isValidForCarrier: Boolean!
  latitude: Float!
  longitude: Float!
  municipality: IdName
  neighborhood: IdName
  state: IdName
  streetName: String!
  streetNumber: String!
  types: [String!]
  zipCode: String!
}

type LogisticHandlingTime {
  accuracy: String!
  logisticType: String!
  predictions: [HandlingTimePredictions]
  source: String!
  unit: String!
  userID: Int!
}

type LogisticInfo {
  carrierPickup: [LogisticService]
  default: Boolean!
  handlingTime: LogisticHandlingTime
  overCapacity: Boolean!
  selfServiceTime: SelfServiceTime
  services: [LogisticService]
  status: String!
  tokenAxado: String!
  warehouses: [LogisticWarehouse]
}

type LogisticService {
  ID: String!
  companyID: String!
  description: String!
}

type LogisticType {
  default: Boolean!
  schedule: [ScheduleDay]
  services: [Int]!
  status: String!
  type: String!
}

type LogisticWarehouse {
  fiscal: String!
  flex: Flex
  integrator: String!
  name: String!
}

type MELogistic {
  crossdocking: Crossdocking
  dropoff: DropOff
  flex: Flex
  fulfillment: Fulfillment
  xddo: CrossdockingDropOff
}

scalar Map

type MediationMessage {
  author: String!
  dateCreated: String!
  dateCreatedNew: String!
  message: String!
  receiverRole: String!
  role: String!
}

type Method {
  method: String!
  methodId: String!
}

type MilkRunDay {
  carrier: MilkRunGenericEntity
  dateCreated: String
  day: String
  driver: MilkRunGenericEntity
  timeWindows: [TimeWindows]
  vehicle: MilkRunVehicle
}

type MilkRunDriver {
  id: ID
  name: String
  type: String
}

type MilkRunGenericEntity {
  id: ID
  name: String
}

type MilkRunIncidentType {
  description: String
  id: ID
}

type MilkRunSellerEntity {
  id: ID
  name: String
  type: String
}

type MilkRunTypeVehicle {
  description: String
  id: ID
}

type MilkRunVehicle {
  id: ID
  licensePlate: String
  type: MilkRunTypeVehicle
  vehicleType: String
}

type MilkrunCarrier {
  ID: Int!
  name: String!
}

type MilkrunDriver {
  ID: Int!
  name: String!
}

type MilkrunHistory {
  carrier: MilkrunCarrier
  configID: String!
  cutoff: String!
  deliveryNotes: [Int]
  driver: MilkrunDriver
  logisticCenter: String!
  specialMilkrun: Boolean!
  vehicle: MilkrunVehicle
  window: String!
}

type MilkrunVehicle {
  ID: Int!
  licensePlate: String!
}

type ModeActions {
  Disabled: Boolean!
  Label: String!
  Name: String!
  Reason: String!
}

type MonthSales {
  amount: Int
  amountME: Int
}

type MovementContainer {
  date: String!
  from: String!
  to: String!
}

type OnlyID {
  Id: Int
}

type OnlyName {
  name: String
}

type Order {
  buyer: OrderBuyer!
  claims: [Claim]
  external: Boolean!
  id: ID!
  orderItem: OrderItem!
  paymentDetail: PaymentDetail!
  payments: [Payment]!
  seller: OrderSeller!
  summaryHandlingTime: SummaryHandlingTime!
}

type OrderBuyer {
  userID: String!
}

input OrderIDS {
  orders: [String]
  shipment: String
}

type OrderItem {
  cost: Float!
  fragile: Boolean
  item: [Item]
  listingTypeId: String
  units: Int!
}

type OrderItemHistory {
  FullUnitPrice: Float
  Item: ItemDetailHistory
  ListingTypeID: String
  Quantity: Int
  UnitPrice: Float
}

type OrderSeller {
  historicReputation: OrderSellerReputation
  orderID: String!
  user: User
  userID: String!
}

type OrderSellerReputation {
  previousLevel: String
  sellerLevel: String
}

type OriginDestination {
  address: String!
  id: String!
  name: String!
  type: String!
}

type Outbound {
  AddedBy: String!
  ClosedBy: String!
  DateClosed: String!
  DateOpened: String!
  ID: String!
  IncludedAt: String!
  Status: String!
  UserIDs: [String]
  WorkstationID: Int!
}

input PaginatedInputWithDate {
  from: String!
  limit: String!
  offset: String!
  sort: String!
  to: String!
}

type Paging {
  limit: Int
  offset: Int
  total: BigInt
}

type Payment {
  ID: ID!
  creditCardSurchage: String!
  date: String!
  isAcredited: Boolean!
  method: String!
  paymentAddition: String!
  productCost: String!
  releaseDate: String!
  shippingCost: String!
  status: String!
  statusDetail: String!
  totalCost: String!
}

type PaymentDetail {
  ID: ID!
  autoPurchase: Boolean!
  currency: Currency!
  date: String!
  fraudRiskDetected: Boolean!
  isDisponibility: Boolean!
  originalPrice: Float!
  releaseDate: String!
  total: Float!
}

type PaymentHistory {
  CurrencyID: String
  DateApproved: String
  DateCreated: String
  DateLastModified: String
  Id: Int
  Method: String
  OperationType: String
  OrderID: Int
  Reason: String
  SiteID: String
  Status: String
  StatusDetail: String
  TotalPaidAmount: Float
  TransactionAmount: Float
}

input PaymentsInput {
  external: Boolean!
  orderID: String!
}

type Phone {
  areaCode: String!
  extension: String!
  number: String!
}

type PlacePoint {
  id: String
  type: String
}

type Poligon {
  geometry: Geometry
  properties: OnlyName
  type: String
}

type Preferences {
  dimension: Dimension!
  logistics: [Logistic!]
  restricted: Boolean!
}

type Price {
  currencyId: String!
  decimalPrice: String!
  decimalSeparator: String!
  integerPrice: String!
  symbol: String!
}

input PrintLabelInput {
  id: String!
}

type PromiseLimit {
  compensated: Boolean!
  date: String!
}

type Purchases {
  detail: SalesDetail
}

input RegenerateLabelInput {
  id: String!
}

input ReputationTagInput {
  id: String!
}

type ReturnShipment {
  id: String!
  pack: String!
  tags: [String]
  type: String!
}

type ReturnTime {
  Date: String!
  DateTo: String!
  Type: String!
  isBold: Boolean!
  isGrey: Boolean!
}

type SaleTerms {
  id: String!
  valueStruct: ItemSTValueStruct!
}

type Sales {
  lastMonth: MonthSales
  thisMonth: MonthSales
  total: MonthSales
}

type SalesDetail {
  availableDateFilters: [AvailableFilters!]
  availableFilters: [AvailableFilters!]
  availableSorts: [FilterValue!]
  dateFilters: [AvailableFilters!]
  filters: [AvailableFilters!]
  orders: [UserOrder!]
  paging: Paging
  sort: FilterValue!
}

type ScheduleDay {
  day: String!
  scheduleDetail: [ScheduleDetail]
}

type ScheduleDetail {
  cutoff: String!
  from: String!
  to: String!
}

input SearchByValue {
  searchBy: String!
  value: String!
}

type SelfServiceConfiguration {
  activationDate: String!
  addressLine: String!
  capacities: Capacities
  city: OnlyName
  creationDate: String!
  cutoffs: Cutoffs
  deliveryWindow: String!
  lastUpdate: String!
  penaltyStatus: String!
  recoverDate: String!
  serviceId: String!
  status: String!
  userId: String!
  zipCode: String!
  zones: [Zones]
}

type SelfServiceTime {
  capacity: Int!
  cutoff: Int!
  deliveryWindow: String!
}

type Seller {
  detail: SellerDetail
  id: String!
  user: User
}

input SellerBilling {
  erp: String!
  integration: String!
}

type SellerDetail {
  logistics: [LogisticType]!
  sales: Sales
  segment: String!
}

type SellerInbounds {
  paging: Paging!
  results: [Inbound]
}

type SellerInventories {
  paging: Paging!
  results: [InventoryItem]
}

type SellerPricingWarehousings {
  fromDate: String
  inventories: [InventoryWarehosingCharge]
  sellerID: ID
  toDate: String
}

type SellerProperties {
  activationDate: String!
  axado: String!
  bulky: Boolean!
  certificate: String!
  certificateType: String!
  fiscalOptin: String!
  flexAllawed: FlexAllowed!
  fragile: String!
  fulfillmentWithSelfService: Boolean!
  modes: [String!]
  professional: String!
  shippingAddress: String!
  shippingOption: String!
  thermalPrinter: String!
  whitelistFlex: Boolean
}

type SellerReputation {
  levelId: String!
  powerSellerStatus: String!
}

type SellerWithdrawals {
  paging: Paging!
  results: [Withdrawal]
}

type Service {
  carrierId: String!
  service: String!
  serviceId: String!
}

type Shipment {
  PackID: String
  header: Header
  id: ID!
  orders: [Order]
  shipmentDetail: ShipmentDetail
  step: Step
  wms: WmsInfo
  address: Address
  type: query_getWithdrawalsRequest_shipment_type
}

type ShipmentCompany {
  id: String!
  name: String!
}

type ShipmentContainer {
  address: Map
  estimatedDeliveryDate: Map
  orderId: String
  parcelId: String
  tracking: [TrackingContainer]
  trackingId: String
  transferUnitId: Int
  type: String!
}

type ShipmentDetail {
  destination: Destination!
  dimensions: Dimension
  fiscalData: ShipmentFiscalData
  id: String!
  isProximity: Boolean!
  keyword: String!
  logisticType: String!
  method: Method
  mode: String!
  origin: Destination!
  service: Service
  shipmentHistory: [ShipmentHistory!]
  shippingCosts: ShippingCosts
  shippingInfo: ShippingInfo
  siteId: String!
  status: String!
  substatus: String!
  time: Time!
  timeZone: String!
  volumetricWeight: String!
}

type ShipmentFiscalData {
  cfop: Int!
  companyStateTaxId: String!
  fiscalKey: String!
  invoiceNumber: String!
}

type ShipmentHistory {
  date: String!
  status: String!
  substatus: String!
}

type ShipmentId {
  id: String!
}

type ShipmentMilestone {
  id: ID!
  manual: String!
  message: String!
  status: String!
  subMilestones: [ShipmentSubMilestone]
}

type ShipmentStatusHistory {
  checkpoints: [Checkpoint!]
  id: ID!
}

type ShipmentSubMilestone {
  date: String!
  id: ID!
  message: String!
  rule: String!
  status: String!
}

type Shipping {
  dimensions: String!
  freeMethod: String!
  freeShipping: Boolean!
  localPickup: Boolean!
  logisticType: String!
  mode: String!
  storePickUp: Boolean!
  tags: [String!]
}

type ShippingCosts {
  buyerCosts: UserCosts
  currencyID: String!
  sellerCosts: UserCosts
}

type ShippingInfo {
  country: String!
  method: String!
  service: String!
}

type ShippingPreferences {
  attributes: [Attribute!]
  catalogProductId: String!
  id: String!
  modes: [String]!
  name: String!
  origin: String!
  preferences: Preferences!
}

type ShpItem {
  acceptsMercadopago: Boolean
  attributes: [ItemAttribute]
  availableQuantity: Int
  basePrice: Float
  bigDecimal: Float
  buyingMode: String
  catalogProductId: String
  categoryId: String
  condition: String
  currencyId: String
  description: String
  domainId: String
  id: String
  initialQuantity: Int
  internationalDeliveryMode: String
  inventoryId: String
  listingTypeId: String
  marketPlace: String
  officialStoreId: Int
  orderId: String
  permalink: String
  pictures: [ItemPicture]
  preferenceId: String
  price: Float
  saleTerms: [ItemSaleTerms]
  sellerId: Int
  shipping: ItemShipping
  shippingId: String
  siteId: String
  soldQuantity: Int
  status: String
  substatus: [String]
  subtitle: String
  tags: [String]
  thumbnail: String
  title: String
  variations: [ItemVariation]
}

type ShpOrder {
  DateCreated: String
  Id: Int
  Items: [OrderItemHistory]
  Payments: [PaymentHistory]
  Shipping: OnlyID
}

type Source {
  identifier: String!
  origin: String!
}

type Step {
  buyer: StepUser
  estimatedDeliveryLimit: String!
  handlingTime: String!
  id: ID!
  promiseDeliveryTime: String!
  seller: StepUser
  shippingCost: String!
  steps: [StepDetail!]
}

type StepDetail {
  carrier: ShipmentCompany!
  destination: OriginDestination!
  finalDate: String!
  id: String!
  inCourse: Boolean!
  initialDate: String!
  isReturn: Boolean!
  logisticCenterID: String!
  logisticProvider: String!
  logisticProviderCity: String!
  origin: OriginDestination!
  point: PlacePoint
  sequence: Int!
  serviceID: Int!
  serviceName: String!
  trackingNumber: String!
  trackingURL: String!
  type: String!
}

type StepUser {
  active: Boolean!
  addresLine: String!
  id: ID!
  nickname: String!
}

type StockDetailWithLocation {
  locations: [LocationDetail]
  saleable: Int
  sellerProductId: String
  total: Int
}

type StockFeeDetail {
  feeAmount: String
  inventoryStatus: String
  quantity: String
}

type SubMotiveInp {
  description: String
  id: String
}

type SummaryClaims {
  dateOpened: String!
  id: String!
  info: String
  reasonId: String!
  riskBuyer: String!
  riskSender: String!
  solutionBuyer: String!
  solutionMediator: [String!]
  solutionSeller: String!
  status: String!
  url: String!
}

type SummaryHandlingTime {
  delayed: Boolean!
  excluded: Boolean!
  handlingTime: Int!
  unit: String!
}

type TagCaseInp {
  message: String
  tag: String
}

type Time {
  delay: Delay
  lead: Lead
}

type TimeLine {
  header: String!
  story: [ShipmentMilestone]
  timelineColor: String!
}

type TimeWindows {
  from: String
  to: String
}

type TmsDevolution {
  Dispatch: TmsDispatch
  Inbound: TmsInbound
  Labeling: Labeling
  Outbound: Outbound
}

type TmsDispatch {
  CarrierID: Int!
  CarrierName: String!
  DateFinished: String!
  DockID: Int!
  ID: String!
  IncludedAt: String!
  Status: String!
  TruckID: String!
  UserID: String!
}

type TmsInbound {
  CarrierID: Int!
  CarrierName: String!
  DateClosed: String!
  DateOpened: String!
  DockID: Int!
  ID: String!
  InboundOperation: String!
  IncludedAt: String!
  Status: String!
  TruckID: String!
  UserID: String!
}

type TmsInfo {
  Devolution: TmsDevolution
  Dispatch: TmsDispatch
  HubStatus: String!
  Inbound: TmsInbound!
  LastMile: Boolean!
  Outbound: TmsOutbound
  Priority: String!
  ShippingOption: Int!
  ShippingType: String!
  StatusDesc: String!
  Substatus: String!
}

type TmsOutbound {
  AddedBy: String!
  DateClosed: String!
  DateOpened: String!
  ID: String!
  IncludedAt: String!
  Status: String!
  UserIDs: [String]
}

type Tracking {
  history: [TrackingNumber]
  shipmentID: String!
}

type TrackingContainer {
  dateTime: String
  step: String
}

type TrackingNumber {
  dateCreated: String!
  number: String!
  plpID: String!
  serviceID: String!
  status: String!
  substatus: String!
}

type UnitContainer {
  details: [UnitContainerDetail]!
  inventoryId: String!
}

type UnitContainerDetail {
  quantity: Int!
  status: String!
}

type User {
  addresses: [Address!]!
  agingDate: String
  email: String!
  firstName: String!
  fullName: String!
  id: BigInt
  identification: Identification!
  internalTags: [String!]
  lastName: String!
  nickname: String
  phone: Phone!
  points: String!
  purchases(input: PaginatedInputWithDate!): SalesDetail!
  sales: UserSales!
  sellerReputation: SellerReputation!
  signature: String!
  siteId: String!
  status: UserStatus!
  tags: [String!]
  test: Boolean!
  userType: String!
}

type UserCosts {
  buyerBillingAmount: Float!
  cost: Float!
  costComponents: CostComponents!
  discount: Discount!
  save: Float!
  userID: String!
  userType: String!
}

input UserFiscalData {
  id: String!
  value: String!
}

type UserOrder {
  amountPaid: String!
  buyer: String!
  currencyId: String!
  logisticType: String!
  method: String!
  offer: String!
  orderId: String!
  orderStatus: String!
  publication: String!
  seller: String!
  status: String!
  subStatus: String!
  title: String!
}

type UserSales {
  amount(input: PaginatedInputWithDate!): Sales
  detail(input: PaginatedInputWithDate!): SalesDetail
  userId: String!
}

type UserStatus {
  mercadopagoAccountType: String!
  siteStatus: String!
}

input UserSubsidiary {
  name: String!
  userFiscalData: [UserFiscalData]
  warehouseId: String!
}

type ValueUnit {
  unit: String!
  value: Int!
}

type Withdrawal {
  ableToReschedule: Boolean
  appointment: Appointment
  appointments: [JSON]
  dateCreated: String
  defaultWarehouseId: String!
  fbppTicketsAlfred: [String!]
  fee: String
  id: BigInt
  lastUpdated: String
  rescheduleDeadline: String
  sellerId: String!
  siteId: String!
  status: query_getWithdrawal_status
  withdrawals: [WithdrawalDetail]
  code: String
  shipment: Shipment
  units: [JSON]
  transfer_plan_id: BigInt
  sub_status: DELAYED_const
  dispatch_id: String
  last_updated: String
  date_created: String
  seller_id: BigInt
  warehouse_id: String
  site_id: String
  withdrawal_request_id: BigInt
  print_action: query_getWithdrawal_print_action
}

type WithdrawalAppointment {
  creationDate: String!
  date: String!
  from: String!
  source: String!
  to: String!
}

type WithdrawalContainer {
  dimensions: Dimensions
  id: String
  lastUpdate: String!
  movements: [JSON]
  parcelId: String!
  sellerId: String!
  shipment: ContainerShipment
  siteId: String!
  status: query_getWithdrawalsContainer_status
  storageAddress: String!
  subStatus: String!
  units: [JSON]
  warehouseId: String!
  withdrawalId: Int!
  withdrawal_id: BigInt
  parcel_id: String
  last_updated: String
  seller_id: BigInt
  warehouse_id: String
  site_id: String
  storage_address: String
}

type WithdrawalDetail {
  appointment: WithdrawalAppointment!
  appointments: [WithdrawalAppointment!]
  containers: [WithdrawalContainer]
  dateCreated: String
  id: ID!
  inventories: [WithdrawalInventory!]
  lastUpdated: String
  status: String!
  subStatus: String!
  type: String
  warehouseId: String!
  withdrawalCharges: [FbmCharge]
}

type WithdrawalInventory {
  collectedQuantity: String!
  deliveredQuantity: String!
  insuranceCost: String!
  inventoryId: String!
  reservedQuantity: String!
  status: String!
}

type WmsInfo {
  EstimatedTimeDeparture: String!
  Status: String!
}

type Zones {
  id: String!
  mandatory: Boolean!
  name: String!
  polygon: Poligon
  price: Price
  required: Boolean!
  selected: Boolean!
}

type dateTm {
  isBold: Boolean!
  isGrey: Boolean!
  value: String!
}

type itemHistory {
  changeDate: String
  item: ShpItem
}

type orderHistory {
  changeDate: String
  order: ShpOrder
}

type printLabelOutput {
  contentLength: Int!
  contentType: String!
  fileName: String!
  fileUrl: String!
}

type WithdrawalRequest {
  appointments: [JSON]
  shipment: Shipment
  fee: Fee
  appointment: Appointment
  units: [JSON]
  title: String
  type: query_getWithdrawalsRequest_type
  version: String
  id: BigInt
  status: query_getWithdrawalsRequest_status
  default_warehouse_id: String
  sub_status: DELAYED_const
  dispatch_id: String
  withdrawal_ids: [BigInt]
  last_updated: String
  seller_id: BigInt
  site_id: String
  print_action: query_getWithdrawalsRequest_print_action
}

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"The `BigInt` scalar type represents non-fractional signed whole numeric values."
scalar BigInt

enum query_getWithdrawalsRequest_shipment_type {
  FTL
  SPD
  SHIPMENT
  DISPOSAL
  TRANSFER
}

type Fee {
  value: Float
  currency_id: String
}

type Appointment {
  date: String
  from: String
  to: String
  source: query_getWithdrawalsRequest_appointment_source
  creation_date: String
}

enum query_getWithdrawalsRequest_appointment_source {
  SELLER
  MELI
}

enum query_getWithdrawalsRequest_type {
  SWH
  MWH
}

enum query_getWithdrawalsRequest_status {
  CREATED
  UNITS_IN_PROGRESS
  UNITS_COMPLETED
  SCHEDULED
  PROCESSING
  CANCELED
  FISCAL_ERROR
  READY_TO_DISPATCH
  APPOINTMENT_EXPIRED
  ABLE_TO_DISCARD
  PARTIALLY_SHIPPED
  COMPLETED
  SHIPPED
  UNFULFILLABLE
  DISCARDED
  DELIVERED
  DELIVERED_WITH_DIFFERENCES
  NOT_DELIVERED
  CONFIRMED
}

enum DELAYED_const {
  DELAYED
}

enum query_getWithdrawalsRequest_print_action {
  PRINT
  REPRINT
  DONE
}

type SearchResultsWithdrawalRequest {
  paging: Paging
  sort: Sorter
  results: [JSON]
  applied_filters: [JSON]
  available_filters: [String]
}

type Sorter {
  field: String
  order: query_searchWithdrawalRequests_sort_order
}

enum query_searchWithdrawalRequests_sort_order {
  asc
  desc
}

type StatusHistoryWithdrawalsRequestStatus {
  status: query_getWithdrawalsRequestHistory_items_status
  event_date: String
}

enum query_getWithdrawalsRequestHistory_items_status {
  CREATED
  UNITS_IN_PROGRESS
  UNITS_COMPLETED
  SCHEDULED
  PROCESSING
  CANCELED
  FISCAL_ERROR
  READY_TO_DISPATCH
  APPOINTMENT_EXPIRED
  ABLE_TO_DISCARD
  PARTIALLY_SHIPPED
  COMPLETED
  SHIPPED
  UNFULFILLABLE
  DISCARDED
  DELIVERED
  DELIVERED_WITH_DIFFERENCES
  NOT_DELIVERED
  CONFIRMED
}

enum query_getWithdrawal_status {
  CREATED
  STOCK_RESERVED
  READY_TO_COLLECT
  COLLECTING
  COLLECTED
  READY_TO_DISPATCH
  APPOINTMENT_EXPIRED
  ABLE_TO_DISCARD
  DOCUMENTED
  COMPLETED
  UNFULFILLABLE
  SHIPPED
  PARTIALLY_SHIPPED
  FISCAL_ERROR
  DISCARDED
  CANCELED
  DELIVERED
  DELIVERED_WITH_DIFFERENCES
  NOT_DELIVERED
}

enum query_getWithdrawal_print_action {
  PRINT
  REPRINT
  DONE
}

type SearchResultsWithdrawal {
  paging: Paging
  sort: Sorter
  results: [JSON]
  applied_filters: [JSON]
  available_filters: [String]
}

type DispatchInfo {
  constraint: query_getWithdrawalReadyToDispatchInfo_constraint
  ready_to_dispatch: Boolean
  dispatch_channel: String
}

enum query_getWithdrawalReadyToDispatchInfo_constraint {
  PENDING_PROCESS
  PROCESSING
  PROCESSED
  CANCELLED
  FISCAL_ERROR
  DOCUMENTED
  COMPLETED
  UNFULFILLABLE
  DISCARDED
}

type ContainerShipment {
  address: Address
  type: query_getWithdrawalsContainer_shipment_type
  tracking: [JSON]
  order_id: String
  transfer_unit_id: BigInt
  estimated_delivery_date: Delivery
  tracking_id: String
  parcel_id: String
}

enum query_getWithdrawalsContainer_shipment_type {
  FTL
  SPD
  SHIPMENT
  DISPOSAL
  TRANSFER
}

type Delivery {
  from: String
  to: String
}

enum query_getWithdrawalsContainer_status {
  CREATED
  STORED
  SHIPPED
  LOST
  DAMAGED
  TRACKED
  READY_TO_DISPATCH
  IN_TRANSFER
  TRANSFERRED
  DISCARDED
  DELIVERED
  NOT_DELIVERED
  FISCAL_ERROR
  IN_POST_OFFICE
  RETURNED_TO_WAREHOUSE
}

enum query_getWithdrawalsContainer_dimensions_length_measure_unit {
  g
  cm
}

type SearchResultsWithdrawalContainer {
  paging: Paging
  sort: Sorter
  results: [JSON]
  applied_filters: [JSON]
  available_filters: [String]
}

type WithdrawalContainerTrackingInfo {
  address: AddressDTO
  user: User
  container_id: String
  dimensions: Dimensions
  withdrawal_id: BigInt
  shipment_type: query_getWithdrawalsContainerTrackingInfo_shipment_type
  tracking_id: String
}

type AddressDTO {
  country: AddressArea
  references: String
  city: AddressArea
  phone: String
  comment: String
  id: BigInt
  state: AddressArea
  zip_code: String
  street_name: String
  street_number: String
  aditional_info: String
  address_line: String
}

type AddressArea {
  name: String
  id: String
}

enum query_getWithdrawalsContainerTrackingInfo_shipment_type {
  FTL
  SPD
  SHIPMENT
  DISPOSAL
  TRANSFER
}

type ContainerDocuments {
  shipping_label: String
  invoice_labels: [String]
  box_id: String
}

input BigQueueMessage_Input {
  msg: EventMessage_Input
}

input EventMessage_Input {
  source_id: String
  event_id: BigInt
}

union list_teams_get_response = TeamResponse | HTTPValidationError

type TeamResponse {
  id: Int!
  code: String!
  name: String!
  enabled: Boolean!
  description: String
}

type HTTPValidationError {
  detail: [ValidationError]
}

type ValidationError {
  loc: [String]!
  msg: String!
  type: String!
}

"An enumeration."
enum TeamOrderEnum {
  asc
  desc
}

union get_by_team_code_teams__team_code__get_response = TeamResponse | HTTPValidationError

union get_teams_by_username_teams_user__username__get_response = TeamUserListResponse | HTTPValidationError

type TeamUserListResponse {
  id: Int!
  code: String!
  name: String!
  enabled: Boolean!
  role: String!
  isTemporary: Boolean!
}

union get_team_collaborators_teams__team_code__collaborators_get_response = TeamUserResponse | HTTPValidationError

type TeamUserResponse {
  id: Int!
  code: String!
  name: String!
  enabled: Boolean!
  description: String
  collaborators: [UserResponse]!
}

type UserResponse {
  id: Int!
  role: String!
  username: String!
  name: String!
  email: String!
  is_temporary: Boolean!
  active: Boolean!
  from_date: String
  to_date: String
  applications: [String]
}

union get_applications_by_team_code_teams__team_code__applications_get_response = String_container | HTTPValidationError

type String_container {
  String: String
}

type RoleResponse {
  id: Int!
  name: String!
  description: String
}

union create_teams_post_response = TeamResponse | HTTPValidationError

input TeamRequest_Input {
  name: String!
  description: String
  collaborators: [TeamUserRequest_Input]!
}

input TeamUserRequest_Input {
  username: String!
  role_name: String!
  full_name: String
  email: String!
  from_date: DateTime
  to_date: DateTime
  is_temporary: Boolean!
  active: Boolean
  applications: [String] = []
}

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

union update_teams__team_code__put_response = Void_container | HTTPValidationError

type Void_container {
  Void: Void
}

"Represents empty values"
scalar Void

input TeamUpdateRequest_Input {
  description: String
  collaborators: [TeamUserRequest_Input]!
}

union delete_teams__team_code__delete_response = Void_container | HTTPValidationError

union refresh_teams__team_code__refresh_post_response = Void_container | HTTPValidationError

union exit_collaborator_teams_exit_collaborator_post_response = Void_container | HTTPValidationError

input SquidExitCollaboratorMessage_Input {
  msg: SquidExitCollaboratorDetail_Input!
}

input SquidExitCollaboratorDetail_Input {
  details: SquidExitCollaboratorUsername_Input!
}

input SquidExitCollaboratorUsername_Input {
  username: String!
}

union create_role_post_response = RoleResponse | HTTPValidationError

input RoleRequest_Input {
  name: String!
  description: String
}